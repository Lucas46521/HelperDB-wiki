
---
title: size
description: Retorna o tamanho de arrays, objetos ou strings armazenados
---

# size()

Retorna o tamanho de arrays, objetos ou strings armazenados, fornecendo informa√ß√µes √∫teis sobre a quantidade de elementos, propriedades ou caracteres contidos nos dados.

## Sintaxe

```typescript
await db.size(key: string): Promise<number>
```

## Par√¢metros

- `key` (obrigat√≥rio): Chave do valor para obter o tamanho

## Retorno

N√∫mero representando:
- Para **arrays**: quantidade de elementos
- Para **objetos**: quantidade de propriedades
- Para **strings**: quantidade de caracteres
- Para outros tipos: `0`

## Exemplos

### Tamanho de Arrays

```javascript
// Arrays com diferentes tamanhos
await db.set('fruits', ['ma√ß√£', 'banana', 'laranja', 'uva']);
await db.set('numbers', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
await db.set('emptyArray', []);

// Verificar tamanhos
const fruitsSize = await db.size('fruits');
console.log(`fruits tem ${fruitsSize} elementos`); // 4

const numbersSize = await db.size('numbers');
console.log(`numbers tem ${numbersSize} elementos`); // 10

const emptySize = await db.size('emptyArray');
console.log(`emptyArray tem ${emptySize} elementos`); // 0

// Array de objetos
await db.set('users', [
  { id: 1, name: 'Jo√£o' },
  { id: 2, name: 'Maria' },
  { id: 3, name: 'Pedro' }
]);

const usersCount = await db.size('users');
console.log(`${usersCount} usu√°rios cadastrados`); // 3
```

### Tamanho de Objetos

```javascript
// Objetos com diferentes quantidades de propriedades
await db.set('user.profile', {
  name: 'Jo√£o Silva',
  age: 30,
  email: 'joao@email.com',
  active: true,
  preferences: {
    theme: 'dark',
    language: 'pt-BR'
  }
});

await db.set('config', {
  host: 'localhost',
  port: 3000,
  debug: true
});

await db.set('emptyObject', {});

// Verificar n√∫mero de propriedades
const profileSize = await db.size('user.profile');
console.log(`profile tem ${profileSize} propriedades`); // 5

const configSize = await db.size('config');
console.log(`config tem ${configSize} propriedades`); // 3

const emptyObjSize = await db.size('emptyObject');
console.log(`emptyObject tem ${emptyObjSize} propriedades`); // 0

// Objeto aninhado
const preferencesSize = await db.size('user.profile.preferences');
console.log(`preferences tem ${preferencesSize} propriedades`); // 2
```

### Tamanho de Strings

```javascript
// Strings de diferentes tamanhos
await db.set('shortText', 'Ol√°');
await db.set('longText', 'Este √© um texto mais longo para testar o m√©todo size');
await db.set('emptyString', '');
await db.set('user.bio', 'Desenvolvedor Full Stack com 5 anos de experi√™ncia');

// Verificar comprimento das strings
const shortSize = await db.size('shortText');
console.log(`shortText tem ${shortSize} caracteres`); // 3

const longSize = await db.size('longText');
console.log(`longText tem ${longSize} caracteres`); // 54

const emptyStrSize = await db.size('emptyString');
console.log(`emptyString tem ${emptyStrSize} caracteres`); // 0

const bioSize = await db.size('user.bio');
console.log(`bio tem ${bioSize} caracteres`); // 48
```

### Sistema de Invent√°rio

```javascript
// Sistema de gest√£o de estoque
await db.set('inventory.electronics', [
  { id: 1, name: 'Laptop', stock: 15 },
  { id: 2, name: 'Mouse', stock: 50 },
  { id: 3, name: 'Keyboard', stock: 25 }
]);

await db.set('inventory.books', [
  { id: 1, title: 'JavaScript Guide', stock: 12 },
  { id: 2, title: 'Python Basics', stock: 8 }
]);

await db.set('inventory.furniture', []);

// Relat√≥rio de invent√°rio
async function generateInventoryReport() {
  console.log('üì¶ Relat√≥rio de Invent√°rio:');
  
  const electronicsCount = await db.size('inventory.electronics');
  const booksCount = await db.size('inventory.books');
  const furnitureCount = await db.size('inventory.furniture');
  
  console.log(`Electronics: ${electronicsCount} tipos de produtos`);
  console.log(`Books: ${booksCount} tipos de produtos`);
  console.log(`Furniture: ${furnitureCount} tipos de produtos`);
  
  const totalCategories = [electronicsCount, booksCount, furnitureCount]
    .filter(count => count > 0).length;
  
  console.log(`\nüìä Resumo: ${totalCategories} categorias ativas`);
  
  // Calcular total de itens √∫nicos
  const totalProducts = electronicsCount + booksCount + furnitureCount;
  console.log(`Total de produtos √∫nicos: ${totalProducts}`);
}

await generateInventoryReport();
```

### Valida√ß√£o de Limites

```javascript
// Sistema com limites de capacidade
await db.set('cart.items', []);
await db.set('favorites.products', []);
await db.set('settings.notifications', {});

const LIMITS = {
  cartMaxItems: 10,
  favoritesMaxItems: 50,
  maxNotificationSettings: 20
};

// Fun√ß√£o para verificar se pode adicionar mais itens
async function canAddToCart() {
  const currentSize = await db.size('cart.items');
  const canAdd = currentSize < LIMITS.cartMaxItems;
  
  console.log(`üõí Carrinho: ${currentSize}/${LIMITS.cartMaxItems} itens`);
  console.log(`Pode adicionar mais: ${canAdd ? 'Sim' : 'N√£o'}`);
  
  return canAdd;
}

async function canAddToFavorites() {
  const currentSize = await db.size('favorites.products');
  const canAdd = currentSize < LIMITS.favoritesMaxItems;
  
  console.log(`‚ù§Ô∏è Favoritos: ${currentSize}/${LIMITS.favoritesMaxItems} itens`);
  console.log(`Pode adicionar mais: ${canAdd ? 'Sim' : 'N√£o'}`);
  
  return canAdd;
}

// Simular adi√ß√£o de itens
for (let i = 1; i <= 12; i++) {
  if (await canAddToCart()) {
    await db.push('cart.items', { id: i, product: `Product ${i}` });
    console.log(`‚úÖ Produto ${i} adicionado ao carrinho`);
  } else {
    console.log(`‚ùå Carrinho cheio! N√£o √© poss√≠vel adicionar produto ${i}`);
    break;
  }
}
```

### Dashboard de Estat√≠sticas

```javascript
// Dados para dashboard
await db.set('analytics.pageViews', Array(1500).fill().map((_, i) => ({
  page: `/page${i % 10}`,
  views: Math.floor(Math.random() * 100)
})));

await db.set('analytics.users', Array(250).fill().map((_, i) => ({
  id: i + 1,
  lastActive: Date.now() - Math.random() * 86400000
})));

await db.set('analytics.errors', Array(45).fill().map((_, i) => ({
  type: 'error',
  timestamp: Date.now() - Math.random() * 86400000
})));

await db.set('system.cache', {
  users: 'cached',
  products: 'cached',
  orders: 'cached',
  analytics: 'cached',
  settings: 'cached',
  notifications: 'cached'
});

// Fun√ß√£o para dashboard
async function generateDashboard() {
  console.log('üìä Dashboard de Estat√≠sticas:');
  console.log('================================');
  
  // Contadores principais
  const pageViewsCount = await db.size('analytics.pageViews');
  const usersCount = await db.size('analytics.users');
  const errorsCount = await db.size('analytics.errors');
  const cacheEntriesCount = await db.size('system.cache');
  
  console.log(`üìà Page Views registradas: ${pageViewsCount.toLocaleString()}`);
  console.log(`üë• Usu√°rios ativos: ${usersCount.toLocaleString()}`);
  console.log(`‚ùå Erros registrados: ${errorsCount}`);
  console.log(`üíæ Entradas em cache: ${cacheEntriesCount}`);
  
  // C√°lculos adicionais
  const avgViewsPerUser = pageViewsCount / usersCount;
  const errorRate = (errorsCount / pageViewsCount * 100);
  
  console.log('\nüìä M√©tricas Calculadas:');
  console.log(`M√©dia de views por usu√°rio: ${avgViewsPerUser.toFixed(2)}`);
  console.log(`Taxa de erro: ${errorRate.toFixed(3)}%`);
  
  // Status do sistema
  console.log('\nüéØ Status do Sistema:');
  console.log(`Cache Health: ${cacheEntriesCount > 0 ? '‚úÖ Ativo' : '‚ùå Inativo'}`);
  console.log(`Error Level: ${errorsCount < 50 ? '‚úÖ Normal' : '‚ö†Ô∏è Alto'}`);
}

await generateDashboard();
```

## Casos de Uso

### üìä **Relat√≥rios e Analytics**
```javascript
// Estat√≠sticas de uso
const totalProducts = await db.size('products');
const totalUsers = await db.size('users');
const totalOrders = await db.size('orders');

console.log(`Sistema: ${totalProducts} produtos, ${totalUsers} usu√°rios, ${totalOrders} pedidos`);
```

### üõ°Ô∏è **Valida√ß√£o de Limites**
```javascript
// Verificar antes de adicionar
const currentItems = await db.size('shoppingCart');
if (currentItems < 10) {
  await db.push('shoppingCart', newItem);
} else {
  throw new Error('Carrinho cheio!');
}
```

### üì± **Pagina√ß√£o Din√¢mica**
```javascript
// Calcular n√∫mero de p√°ginas
const totalItems = await db.size('products');
const itemsPerPage = 20;
const totalPages = Math.ceil(totalItems / itemsPerPage);

console.log(`${totalItems} produtos em ${totalPages} p√°ginas`);
```

### üéØ **Performance Monitoring**
```javascript
// Monitorar crescimento de dados
const cacheSize = await db.size('cache');
const logSize = await db.size('logs');

if (cacheSize > 1000) {
  console.log('‚ö†Ô∏è Cache muito grande, considere limpeza');
}

if (logSize > 5000) {
  console.log('‚ö†Ô∏è Muitos logs, considere arquivamento');
}
```

## Caracter√≠sticas Importantes

### üéØ **Flexibilidade de Tipos**
- Funciona com arrays, objetos e strings
- Retorna 0 para tipos n√£o suportados
- Suporte completo a estruturas aninhadas

### ‚ö° **Performance Otimizada**
- Opera√ß√£o r√°pida sem carregar dados completos
- N√£o afeta o valor armazenado
- Cache interno para melhor performance

### üîß **Integra√ß√£o Perfeita**
- Combina bem com outros m√©todos
- Essencial para valida√ß√µes e controles
- Suporte a nota√ß√£o de ponto

## Valida√ß√£o e Erros

```javascript
// ‚ùå Erro: Chave deve ser string
try {
  await db.size(123);
} catch (error) {
  console.log(error.message); // "Key must be a string"
}

// ‚úÖ Chave n√£o existe
const nonExistentSize = await db.size('nonexistent.key');
console.log(nonExistentSize); // 0

// ‚úÖ Tipos n√£o suportados retornam 0
await db.set('numberValue', 42);
await db.set('booleanValue', true);
await db.set('nullValue', null);

console.log(await db.size('numberValue')); // 0
console.log(await db.size('booleanValue')); // 0
console.log(await db.size('nullValue')); // 0

// ‚úÖ Verifica√ß√£o de propriedade aninhada
await db.set('nested', { level1: { level2: [1, 2, 3] } });
const nestedSize = await db.size('nested.level1.level2');
console.log(nestedSize); // 3
```

## M√©todos Relacionados

- [`count()`](./count.mdx) - Conta registros que atendem crit√©rios
- [`type()`](./type.mdx) - Verifica tipo do valor
- [`get()`](./get.mdx) - Obt√©m valor para inspecionar
- [`has()`](./has.mdx) - Verifica exist√™ncia de chave
- [`all()`](./all.mdx) - Lista todos os dados

## Utilit√°rios Avan√ßados

```javascript
// Classe para an√°lise de tamanhos
class SizeAnalyzer {
  constructor(db) {
    this.db = db;
  }
  
  async analyzeDataSizes(pattern = '') {
    const allData = await this.db.all();
    const analysis = {
      arrays: [],
      objects: [],
      strings: [],
      totalSize: 0
    };
    
    for (const { key } of allData) {
      if (pattern && !key.includes(pattern)) continue;
      
      const type = await this.db.type(key);
      const size = await this.db.size(key);
      
      const entry = { key, size };
      
      switch (type) {
        case 'array':
          analysis.arrays.push(entry);
          break;
        case 'object':
          analysis.objects.push(entry);
          break;
        case 'string':
          analysis.strings.push(entry);
          break;
      }
      
      analysis.totalSize += size;
    }
    
    // Ordenar por tamanho (maior primeiro)
    analysis.arrays.sort((a, b) => b.size - a.size);
    analysis.objects.sort((a, b) => b.size - a.size);
    analysis.strings.sort((a, b) => b.size - a.size);
    
    return analysis;
  }
  
  async findLargestData(limit = 10) {
    const allData = await this.db.all();
    const sizesWithKeys = [];
    
    for (const { key } of allData) {
      const size = await this.db.size(key);
      const type = await this.db.type(key);
      sizesWithKeys.push({ key, size, type });
    }
    
    return sizesWithKeys
      .sort((a, b) => b.size - a.size)
      .slice(0, limit);
  }
  
  async generateSizeReport() {
    const analysis = await this.analyzeDataSizes();
    const largest = await this.findLargestData(5);
    
    console.log('üìä Relat√≥rio de Tamanhos:');
    console.log('==========================');
    
    console.log(`Arrays: ${analysis.arrays.length} (total elements: ${analysis.arrays.reduce((sum, a) => sum + a.size, 0)})`);
    console.log(`Objects: ${analysis.objects.length} (total properties: ${analysis.objects.reduce((sum, o) => sum + o.size, 0)})`);
    console.log(`Strings: ${analysis.strings.length} (total characters: ${analysis.strings.reduce((sum, s) => sum + s.size, 0)})`);
    
    console.log('\nüéØ Maiores estruturas:');
    largest.forEach((item, index) => {
      console.log(`${index + 1}. ${item.key} (${item.type}): ${item.size}`);
    });
    
    return analysis;
  }
}

// Uso da an√°lise
const analyzer = new SizeAnalyzer(db);
await analyzer.generateSizeReport();
```

## Dicas de Performance

```javascript
// ‚úÖ Use size() para valida√ß√µes r√°pidas
const cartSize = await db.size('cart');
if (cartSize < MAX_CART_ITEMS) {
  // Adicionar item
}

// ‚úÖ Monitore crescimento de dados
const logSize = await db.size('logs');
if (logSize > 1000) {
  // Limpar logs antigos
  await db.set('logs', []);
}

// ‚úÖ Otimize carregamento baseado no tamanho
const dataSize = await db.size('heavyData');
if (dataSize > 100) {
  // Carregar com pagina√ß√£o
  const firstBatch = await db.limit(50, 'heavyData');
} else {
  // Carregar tudo
  const allData = await db.get('heavyData');
}

// ‚úÖ Use para relat√≥rios eficientes
const summary = {
  users: await db.size('users'),
  products: await db.size('products'),
  orders: await db.size('orders')
};
```
