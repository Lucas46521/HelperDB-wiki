
---
title: type
description: Verifica e retorna o tipo de dados de um valor armazenado
---

# type()

Verifica e retorna o tipo de dados de um valor armazenado, proporcionando informa√ß√µes detalhadas sobre a estrutura dos dados para valida√ß√£o, debugging e l√≥gica condicional.

## Sintaxe

```typescript
await db.type(key: string): Promise<string>
```

## Par√¢metros

- `key` (obrigat√≥rio): Chave do valor para verificar o tipo

## Retorno

String indicando o tipo do valor: `'string'`, `'number'`, `'boolean'`, `'object'`, `'array'`, `'null'`, `'undefined'`

## Exemplos

### Verifica√ß√£o de Tipos B√°sicos

```javascript
// Diferentes tipos de dados
await db.set('userName', 'Jo√£o Silva');
await db.set('userAge', 25);
await db.set('isActive', true);
await db.set('config', null);

// Verificar tipos
const nameType = await db.type('userName');
console.log(`userName √© do tipo: ${nameType}`); // string

const ageType = await db.type('userAge');
console.log(`userAge √© do tipo: ${ageType}`); // number

const activeType = await db.type('isActive');
console.log(`isActive √© do tipo: ${activeType}`); // boolean

const configType = await db.type('config');
console.log(`config √© do tipo: ${configType}`); // null
```

### Verifica√ß√£o de Estruturas Complexas

```javascript
// Dados complexos
await db.set('user.profile', {
  name: 'Jo√£o',
  age: 25,
  preferences: {
    theme: 'dark',
    language: 'pt-BR'
  }
});

await db.set('user.hobbies', ['programa√ß√£o', 'leitura', 'm√∫sica']);

await db.set('user.scores', [95, 87, 92, 88]);

// Verificar tipos de estruturas
const profileType = await db.type('user.profile');
console.log(`user.profile √© do tipo: ${profileType}`); // object

const hobbiesType = await db.type('user.hobbies');
console.log(`user.hobbies √© do tipo: ${hobbiesType}`); // array

const scoresType = await db.type('user.scores');
console.log(`user.scores √© do tipo: ${scoresType}`); // array

// Verificar propriedades espec√≠ficas
const nameType = await db.type('user.profile.name');
console.log(`user.profile.name √© do tipo: ${nameType}`); // string

const themeType = await db.type('user.profile.preferences.theme');
console.log(`user.profile.preferences.theme √© do tipo: ${themeType}`); // string
```

### Valida√ß√£o de Dados de API

```javascript
// Simular resposta de API armazenada
await db.set('api.users', [
  { id: 1, name: 'Jo√£o', active: true, salary: 5000.50 },
  { id: 2, name: 'Maria', active: false, salary: 6200.00 }
]);

await db.set('api.config', {
  version: '1.0',
  timeout: 5000,
  retries: 3,
  endpoints: ['users', 'products', 'orders']
});

// Validar estrutura dos dados recebidos
async function validateApiData() {
  console.log('üîç Validando estrutura dos dados da API...');
  
  // Verificar se users √© array
  const usersType = await db.type('api.users');
  console.log(`‚úÖ api.users: ${usersType}`);
  
  if (usersType === 'array') {
    const users = await db.get('api.users');
    console.log(`   Cont√©m ${users.length} usu√°rios`);
    
    // Verificar tipo do primeiro usu√°rio
    if (users.length > 0) {
      await db.set('temp.firstUser', users[0]);
      const firstUserType = await db.type('temp.firstUser');
      console.log(`   Primeiro usu√°rio: ${firstUserType}`);
      
      // Verificar propriedades espec√≠ficas
      const idType = await db.type('temp.firstUser.id');
      const nameType = await db.type('temp.firstUser.name');
      const activeType = await db.type('temp.firstUser.active');
      const salaryType = await db.type('temp.firstUser.salary');
      
      console.log(`   id: ${idType}, name: ${nameType}, active: ${activeType}, salary: ${salaryType}`);
    }
  }
  
  // Verificar configura√ß√£o
  const configType = await db.type('api.config');
  console.log(`‚úÖ api.config: ${configType}`);
  
  if (configType === 'object') {
    const versionType = await db.type('api.config.version');
    const timeoutType = await db.type('api.config.timeout');
    const endpointsType = await db.type('api.config.endpoints');
    
    console.log(`   version: ${versionType}, timeout: ${timeoutType}, endpoints: ${endpointsType}`);
  }
}

await validateApiData();
```

### Sistema de Valida√ß√£o Din√¢mica

```javascript
// Schema de valida√ß√£o
const userSchema = {
  name: 'string',
  age: 'number',
  isActive: 'boolean',
  preferences: 'object',
  hobbies: 'array'
};

// Fun√ß√£o de valida√ß√£o usando type()
async function validateUserData(userKey) {
  console.log(`üîç Validando dados do usu√°rio: ${userKey}`);
  
  const errors = [];
  
  for (const [field, expectedType] of Object.entries(userSchema)) {
    const fullKey = `${userKey}.${field}`;
    const actualType = await db.type(fullKey);
    
    if (actualType === 'undefined') {
      errors.push(`Campo obrigat√≥rio '${field}' n√£o encontrado`);
    } else if (actualType !== expectedType) {
      errors.push(`Campo '${field}' deveria ser '${expectedType}', mas √© '${actualType}'`);
    } else {
      console.log(`   ‚úÖ ${field}: ${actualType}`);
    }
  }
  
  if (errors.length > 0) {
    console.log('‚ùå Erros de valida√ß√£o:');
    errors.forEach(error => console.log(`   - ${error}`));
    return false;
  } else {
    console.log('‚úÖ Todos os campos s√£o v√°lidos');
    return true;
  }
}

// Teste com dados v√°lidos
await db.set('user.valid', {
  name: 'Jo√£o Silva',
  age: 30,
  isActive: true,
  preferences: { theme: 'dark' },
  hobbies: ['programa√ß√£o', 'leitura']
});

await validateUserData('user.valid');

// Teste com dados inv√°lidos
await db.set('user.invalid', {
  name: 123, // Deveria ser string
  age: '30', // Deveria ser number
  isActive: 'true', // Deveria ser boolean
  preferences: ['array'], // Deveria ser object
  // hobbies ausente
});

await validateUserData('user.invalid');
```

### Debug e Troubleshooting

```javascript
// Fun√ß√£o para debug de dados desconhecidos
async function debugData(key) {
  console.log(`üîß Debug de dados: ${key}`);
  
  const type = await db.type(key);
  console.log(`Tipo: ${type}`);
  
  if (type === 'undefined') {
    console.log('‚ùå Chave n√£o existe');
    return;
  }
  
  const value = await db.get(key);
  
  switch (type) {
    case 'string':
      console.log(`Valor: "${value}" (${value.length} caracteres)`);
      break;
      
    case 'number':
      console.log(`Valor: ${value} (${Number.isInteger(value) ? 'inteiro' : 'decimal'})`);
      break;
      
    case 'boolean':
      console.log(`Valor: ${value}`);
      break;
      
    case 'array':
      console.log(`Array com ${value.length} elementos:`);
      value.forEach((item, index) => {
        console.log(`  [${index}]: ${typeof item} - ${JSON.stringify(item)}`);
      });
      break;
      
    case 'object':
      if (value === null) {
        console.log('Valor: null');
      } else {
        const keys = Object.keys(value);
        console.log(`Objeto com ${keys.length} propriedades:`);
        keys.forEach(key => {
          console.log(`  ${key}: ${typeof value[key]} - ${JSON.stringify(value[key])}`);
        });
      }
      break;
      
    default:
      console.log(`Valor: ${JSON.stringify(value)}`);
  }
}

// Exemplos de debug
await db.set('debug.string', 'Hello World');
await db.set('debug.number', 42.5);
await db.set('debug.array', [1, 'two', true, { four: 4 }]);
await db.set('debug.object', { name: 'Test', nested: { value: 123 } });

await debugData('debug.string');
await debugData('debug.number');
await debugData('debug.array');
await debugData('debug.object');
await debugData('debug.nonexistent');
```

## Casos de Uso

### ‚úÖ **Valida√ß√£o de Dados**
```javascript
// Validar antes de opera√ß√µes espec√≠ficas
const scoreType = await db.type('user.score');
if (scoreType === 'number') {
  await db.add('user.score', 10);
} else {
  console.log('Score deve ser um n√∫mero para somar');
}
```

### üîç **Debugging e Logs**
```javascript
// Log detalhado para debugging
async function logDataStructure(key) {
  const type = await db.type(key);
  console.log(`[DEBUG] ${key}: ${type}`);
  
  if (type === 'object') {
    const value = await db.get(key);
    console.log(`[DEBUG] Properties: ${Object.keys(value).join(', ')}`);
  }
}
```

### üõ°Ô∏è **Verifica√ß√£o de Integridade**
```javascript
// Verificar integridade de dados cr√≠ticos
async function checkDataIntegrity() {
  const criticalKeys = ['user.id', 'user.email', 'user.permissions'];
  
  for (const key of criticalKeys) {
    const type = await db.type(key);
    if (type === 'undefined') {
      throw new Error(`Dados cr√≠ticos ausentes: ${key}`);
    }
  }
}
```

### üîÑ **Migra√ß√£o de Dados**
```javascript
// Converter tipos durante migra√ß√£o
async function migrateStringToNumber(key) {
  const type = await db.type(key);
  
  if (type === 'string') {
    const value = await db.get(key);
    const numValue = parseFloat(value);
    
    if (!isNaN(numValue)) {
      await db.set(key, numValue);
      console.log(`Migrado ${key}: string -> number`);
    }
  }
}
```

## Caracter√≠sticas Importantes

### üéØ **Detec√ß√£o Precisa**
- Distingue entre arrays e objetos
- Identifica null separadamente de undefined
- Reconhece todos os tipos primitivos JavaScript

### ‚ö° **Performance Otimizada**
- Opera√ß√£o r√°pida sem carregar dados grandes
- Cache interno para verifica√ß√µes repetidas
- N√£o afeta o valor armazenado

### üîß **Compatibilidade Total**
- Funciona com nota√ß√£o de ponto para propriedades aninhadas
- Suporta todos os drivers dispon√≠veis
- Comportamento consistente entre diferentes ambientes

## Valida√ß√£o e Erros

```javascript
// ‚ùå Erro: Chave deve ser string
try {
  await db.type(123);
} catch (error) {
  console.log(error.message); // "Key must be a string"
}

// ‚úÖ Chave n√£o existe
const nonExistentType = await db.type('nonexistent.key');
console.log(nonExistentType); // 'undefined'

// ‚úÖ Verifica√ß√£o de propriedade aninhada inexistente
await db.set('obj', { a: 1 });
const missingProp = await db.type('obj.b.c');
console.log(missingProp); // 'undefined'

// ‚úÖ Diferentes tipos de null/undefined
await db.set('nullValue', null);
await db.set('undefinedValue', undefined);

const nullType = await db.type('nullValue');
const undefinedType = await db.type('undefinedValue');

console.log(nullType); // 'null'
console.log(undefinedType); // 'undefined'
```

## M√©todos Relacionados

- [`get()`](./get.mdx) - Obter valor para inspecionar
- [`has()`](./has.mdx) - Verificar exist√™ncia de chave
- [`set()`](./set.mdx) - Definir valores com tipo espec√≠fico
- [`size()`](./size.mdx) - Obter tamanho de arrays/objetos
- [`all()`](./all.mdx) - Listar todos os dados para an√°lise

## Utilit√°rios Avan√ßados

```javascript
// Classe para an√°lise de tipos
class TypeAnalyzer {
  constructor(db) {
    this.db = db;
  }
  
  async analyzeStructure(keyPattern = '') {
    const allData = await this.db.all();
    const analysis = {};
    
    for (const { key, value } of allData) {
      if (keyPattern && !key.includes(keyPattern)) continue;
      
      const type = await this.db.type(key);
      
      if (!analysis[type]) {
        analysis[type] = { count: 0, keys: [] };
      }
      
      analysis[type].count++;
      analysis[type].keys.push(key);
    }
    
    return analysis;
  }
  
  async findTypeInconsistencies(keyPattern) {
    const allData = await this.db.all();
    const inconsistencies = [];
    
    // Agrupar por padr√£o de chave
    const patterns = {};
    
    for (const { key } of allData) {
      if (!key.includes(keyPattern)) continue;
      
      const baseKey = key.replace(/\.\d+/g, '.N'); // user.1 -> user.N
      const type = await this.db.type(key);
      
      if (!patterns[baseKey]) {
        patterns[baseKey] = new Set();
      }
      patterns[baseKey].add(type);
    }
    
    // Encontrar padr√µes com tipos inconsistentes
    for (const [pattern, types] of Object.entries(patterns)) {
      if (types.size > 1) {
        inconsistencies.push({
          pattern,
          types: Array.from(types)
        });
      }
    }
    
    return inconsistencies;
  }
}

// Uso da an√°lise
const analyzer = new TypeAnalyzer(db);

// Analisar toda a estrutura
const analysis = await analyzer.analyzeStructure();
console.log('üìä An√°lise de tipos:', analysis);

// Encontrar inconsist√™ncias
const inconsistencies = await analyzer.findTypeInconsistencies('user');
if (inconsistencies.length > 0) {
  console.log('‚ö†Ô∏è Inconsist√™ncias encontradas:', inconsistencies);
}
```

## Dicas de Performance

```javascript
// ‚úÖ Use type() para valida√ß√£o r√°pida antes de opera√ß√µes
const userIdType = await db.type('user.id');
if (userIdType === 'number') {
  // Proceder com opera√ß√µes num√©ricas
}

// ‚úÖ Cache resultados de type() para verifica√ß√µes repetidas
const typeCache = new Map();
async function getCachedType(key) {
  if (!typeCache.has(key)) {
    typeCache.set(key, await db.type(key));
  }
  return typeCache.get(key);
}

// ‚úÖ Use para debugging inteligente
if (process.env.NODE_ENV === 'development') {
  const debugType = await db.type('debug.data');
  console.log(`Debug data type: ${debugType}`);
}

// ‚úÖ Combine com outras verifica√ß√µes
const hasKey = await db.has('user.preferences');
const keyType = hasKey ? await db.type('user.preferences') : 'undefined';
```
